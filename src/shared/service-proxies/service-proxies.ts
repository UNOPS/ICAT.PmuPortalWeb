/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.5.0 (NJsonSchema v10.6.6.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AppControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getHello(): Observable<string> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHello(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetHello(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    test(): Observable<void> {
        let url_ = this.baseUrl + "/test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }
}

@Injectable()
export class DocumentControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    uploadFile(): Observable<any> {
        let url_ = this.baseUrl + "/document/upload";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    deleteDoc(docId: number): Observable<void> {
        let url_ = this.baseUrl + "/document/delete/{docId}";
        if (docId === undefined || docId === null)
            throw new Error("The parameter 'docId' must be defined.");
        url_ = url_.replace("{docId}", encodeURIComponent("" + docId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDoc(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDoc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    getDocuments(oid: number, owner: number): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/getDocument/{oid}/{owner}";
        if (oid === undefined || oid === null)
            throw new Error("The parameter 'oid' must be defined.");
        url_ = url_.replace("{oid}", encodeURIComponent("" + oid));
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Documents.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    getDocumentsForViweCountry(oid: number): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/getDocumentsForViweCountry?";
        if (oid === undefined || oid === null)
            throw new Error("The parameter 'oid' must be defined and cannot be null.");
        else
            url_ += "oid=" + encodeURIComponent("" + oid) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentsForViweCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentsForViweCountry(<any>response_);
                } catch (e) {
                    return <Observable<Documents[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentsForViweCountry(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Documents.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    downloadDocuments(did: number, state: string): Observable<void> {
        let url_ = this.baseUrl + "/document/downloadDocument/{state}/{did}";
        if (did === undefined || did === null)
            throw new Error("The parameter 'did' must be defined.");
        url_ = url_.replace("{did}", encodeURIComponent("" + did));
        if (state === undefined || state === null)
            throw new Error("The parameter 'state' must be defined.");
        url_ = url_.replace("{state}", encodeURIComponent("" + state));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadDocuments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Retrieve a single Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseDocumentControllerDocuments(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single Documents
     * @return Response
     */
    updateOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single Documents
     * @return Response
     */
    replaceOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single Documents
     * @return Delete one base response
     */
    deleteOneBaseDocumentControllerDocuments(id: number): Observable<void> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseDocumentControllerDocuments(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyDocumentsResponseDto> {
        let url_ = this.baseUrl + "/document?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<GetManyDocumentsResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyDocumentsResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<GetManyDocumentsResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyDocumentsResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create a single Documents
     * @return Get create one base response
     */
    createOneBaseDocumentControllerDocuments(body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Documents.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple Documents
     * @return Get create many base response
     */
    createManyBaseDocumentControllerDocuments(body: CreateManyDocumentsDto): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Documents.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve a single User
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUsersControllerUser(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUsersControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single User
     * @return Response
     */
    updateOneBaseUsersControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUsersControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single User
     * @return Response
     */
    replaceOneBaseUsersControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUsersControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single User
     * @return Delete one base response
     */
    deleteOneBaseUsersControllerUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUsersControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseUsersControllerUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple Users
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUsersControllerUser(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUserResponseDto> {
        let url_ = this.baseUrl + "/users?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUsersControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<GetManyUserResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyUserResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseUsersControllerUser(response: HttpResponseBase): Observable<GetManyUserResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUserResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create a single User
     * @return Get create one base response
     */
    createOneBaseUsersControllerUser(body: User): Observable<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUsersControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseUsersControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = User.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple Users
     * @return Get create many base response
     */
    createManyBaseUsersControllerUser(body: CreateManyUserDto): Observable<User[]> {
        let url_ = this.baseUrl + "/users/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUsersControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUsersControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseUsersControllerUser(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(User.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve a single AssignedES
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseAssignedESsControllerAssignedES(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseAssignedESsControllerAssignedES(<any>response_);
                } catch (e) {
                    return <Observable<AssignedES>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedES>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssignedES.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single AssignedES
     * @return Response
     */
    updateOneBaseAssignedESsControllerAssignedES(id: number, body: AssignedES): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseAssignedESsControllerAssignedES(<any>response_);
                } catch (e) {
                    return <Observable<AssignedES>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedES>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssignedES.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single AssignedES
     * @return Response
     */
    replaceOneBaseAssignedESsControllerAssignedES(id: number, body: AssignedES): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseAssignedESsControllerAssignedES(<any>response_);
                } catch (e) {
                    return <Observable<AssignedES>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedES>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssignedES.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single AssignedES
     * @return Delete one base response
     */
    deleteOneBaseAssignedESsControllerAssignedES(id: number): Observable<void> {
        let url_ = this.baseUrl + "/assigned-ES/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseAssignedESsControllerAssignedES(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple AssignedES
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseAssignedESsControllerAssignedES(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyAssignedESResponseDto> {
        let url_ = this.baseUrl + "/assigned-ES?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseAssignedESsControllerAssignedES(<any>response_);
                } catch (e) {
                    return <Observable<GetManyAssignedESResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyAssignedESResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<GetManyAssignedESResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyAssignedESResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create a single AssignedES
     * @return Get create one base response
     */
    createOneBaseAssignedESsControllerAssignedES(body: AssignedES): Observable<AssignedES> {
        let url_ = this.baseUrl + "/assigned-ES";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseAssignedESsControllerAssignedES(<any>response_);
                } catch (e) {
                    return <Observable<AssignedES>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedES>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = AssignedES.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple AssignedES
     * @return Get create many base response
     */
    createManyBaseAssignedESsControllerAssignedES(body: CreateManyAssignedESDto): Observable<AssignedES[]> {
        let url_ = this.baseUrl + "/assigned-ES/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseAssignedESsControllerAssignedES(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseAssignedESsControllerAssignedES(<any>response_);
                } catch (e) {
                    return <Observable<AssignedES[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssignedES[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseAssignedESsControllerAssignedES(response: HttpResponseBase): Observable<AssignedES[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(AssignedES.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve a single Country
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseCountryControllerCountry(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseCountryControllerCountry(<any>response_);
                } catch (e) {
                    return <Observable<Country>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Update a single Country
     * @return Response
     */
    updateOneBaseCountryControllerCountry(id: number, body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseCountryControllerCountry(<any>response_);
                } catch (e) {
                    return <Observable<Country>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Replace a single Country
     * @return Response
     */
    replaceOneBaseCountryControllerCountry(id: number, body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseCountryControllerCountry(<any>response_);
                } catch (e) {
                    return <Observable<Country>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Country.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Delete a single Country
     * @return Delete one base response
     */
    deleteOneBaseCountryControllerCountry(id: number): Observable<void> {
        let url_ = this.baseUrl + "/country/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseCountryControllerCountry(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Retrieve multiple Countries
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseCountryControllerCountry(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyCountryResponseDto> {
        let url_ = this.baseUrl + "/country?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseCountryControllerCountry(<any>response_);
                } catch (e) {
                    return <Observable<GetManyCountryResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyCountryResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseCountryControllerCountry(response: HttpResponseBase): Observable<GetManyCountryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyCountryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create a single Country
     * @return Get create one base response
     */
    createOneBaseCountryControllerCountry(body: Country): Observable<Country> {
        let url_ = this.baseUrl + "/country";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseCountryControllerCountry(<any>response_);
                } catch (e) {
                    return <Observable<Country>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Country.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    /**
     * Create multiple Countries
     * @return Get create many base response
     */
    createManyBaseCountryControllerCountry(body: CreateManyCountryDto): Observable<Country[]> {
        let url_ = this.baseUrl + "/country/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseCountryControllerCountry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseCountryControllerCountry(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseCountryControllerCountry(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Country.fromJS(item));
            }
            else {
                result201 = <any>null;
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }
}

@Injectable()
export class UsersControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUserDetailsWithLoginProfile(id: number): Observable<UserWithLoginProfileDto> {
        let url_ = this.baseUrl + "/users/with-login-profile?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDetailsWithLoginProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDetailsWithLoginProfile(<any>response_);
                } catch (e) {
                    return <Observable<UserWithLoginProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserWithLoginProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDetailsWithLoginProfile(response: HttpResponseBase): Observable<UserWithLoginProfileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserWithLoginProfileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }

    addMasterAdmin(body: CreateUserDto): Observable<any> {
        let url_ = this.baseUrl + "/users/add-master-admin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMasterAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMasterAdmin(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processAddMasterAdmin(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 !== undefined ? resultData201 : <any>null;
    
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(<any>null);
    }
}

export class GetManyDocumentsResponseDto implements IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyDocumentsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Documents.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyDocumentsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyDocumentsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyDocumentsResponseDto {
        const json = this.toJSON();
        let result = new GetManyDocumentsResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Documents implements IDocuments {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    type: string;
    url: string;

    constructor(data?: IDocuments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.mimeType = _data["mimeType"];
            this.fileName = _data["fileName"];
            this.relativePath = _data["relativePath"];
            this.type = _data["type"];
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): Documents {
        data = typeof data === 'object' ? data : {};
        let result = new Documents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["mimeType"] = this.mimeType;
        data["fileName"] = this.fileName;
        data["relativePath"] = this.relativePath;
        data["type"] = this.type;
        data["url"] = this.url;
        return data;
    }

    clone(): Documents {
        const json = this.toJSON();
        let result = new Documents();
        result.init(json);
        return result;
    }
}

export interface IDocuments {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    type: string;
    url: string;
}

export class CreateManyDocumentsDto implements ICreateManyDocumentsDto {
    bulk: Documents[];

    constructor(data?: ICreateManyDocumentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Documents.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyDocumentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyDocumentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyDocumentsDto {
        const json = this.toJSON();
        let result = new CreateManyDocumentsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyDocumentsDto {
    bulk: Documents[];
}

export class GetManyUserResponseDto implements IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUserResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(User.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUserResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUserResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyUserResponseDto {
        const json = this.toJSON();
        let result = new GetManyUserResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class User implements IUser {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    firstName: string;
    lastName: string;
    email: string;
    telephone: string;
    designation: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    loginProfile: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.telephone = _data["telephone"];
            this.designation = _data["designation"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.canNotDelete = _data["canNotDelete"];
            this.loginProfile = _data["loginProfile"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["telephone"] = this.telephone;
        data["designation"] = this.designation;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["canNotDelete"] = this.canNotDelete;
        data["loginProfile"] = this.loginProfile;
        return data;
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    firstName: string;
    lastName: string;
    email: string;
    telephone: string;
    designation: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    loginProfile: string;
}

export class UserWithLoginProfileDto implements IUserWithLoginProfileDto {
    user: User;
    userName: string;
    roles: string[];

    constructor(data?: IUserWithLoginProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.userName = _data["userName"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles.push(item);
            }
        }
    }

    static fromJS(data: any): UserWithLoginProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserWithLoginProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }

    clone(): UserWithLoginProfileDto {
        const json = this.toJSON();
        let result = new UserWithLoginProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUserWithLoginProfileDto {
    user: User;
    userName: string;
    roles: string[];
}

export class CreateUserDto implements ICreateUserDto {
    firstName: string;
    lastName: string;
    email: string;
    designation: string;
    telephone: string;
    loginProfile: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.designation = _data["designation"];
            this.telephone = _data["telephone"];
            this.loginProfile = _data["loginProfile"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["designation"] = this.designation;
        data["telephone"] = this.telephone;
        data["loginProfile"] = this.loginProfile;
        return data;
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    firstName: string;
    lastName: string;
    email: string;
    designation: string;
    telephone: string;
    loginProfile: string;
}

export class CreateManyUserDto implements ICreateManyUserDto {
    bulk: User[];

    constructor(data?: ICreateManyUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyUserDto {
        const json = this.toJSON();
        let result = new CreateManyUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUserDto {
    bulk: User[];
}

export class GetManyAssignedESResponseDto implements IGetManyAssignedESResponseDto {
    data: AssignedES[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyAssignedESResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(AssignedES.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyAssignedESResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyAssignedESResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyAssignedESResponseDto {
        const json = this.toJSON();
        let result = new GetManyAssignedESResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyAssignedESResponseDto {
    data: AssignedES[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class AssignedES implements IAssignedES {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    user: User;
    add: boolean;
    edit: boolean;
    delete: boolean;

    constructor(data?: IAssignedES) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.add = _data["add"];
            this.edit = _data["edit"];
            this.delete = _data["delete"];
        }
    }

    static fromJS(data: any): AssignedES {
        data = typeof data === 'object' ? data : {};
        let result = new AssignedES();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["add"] = this.add;
        data["edit"] = this.edit;
        data["delete"] = this.delete;
        return data;
    }

    clone(): AssignedES {
        const json = this.toJSON();
        let result = new AssignedES();
        result.init(json);
        return result;
    }
}

export interface IAssignedES {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    user: User;
    add: boolean;
    edit: boolean;
    delete: boolean;
}

export class CreateManyAssignedESDto implements ICreateManyAssignedESDto {
    bulk: AssignedES[];

    constructor(data?: ICreateManyAssignedESDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(AssignedES.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyAssignedESDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyAssignedESDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyAssignedESDto {
        const json = this.toJSON();
        let result = new CreateManyAssignedESDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyAssignedESDto {
    bulk: AssignedES[];
}

export class GetManyCountryResponseDto implements IGetManyCountryResponseDto {
    data: Country[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyCountryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Country.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyCountryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyCountryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data;
    }

    clone(): GetManyCountryResponseDto {
        const json = this.toJSON();
        let result = new GetManyCountryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyCountryResponseDto {
    data: Country[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Country implements ICountry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["id"] = this.id;
        data["name"] = this.name;
        data["code"] = this.code;
        return data;
    }

    clone(): Country {
        const json = this.toJSON();
        let result = new Country();
        result.init(json);
        return result;
    }
}

export interface ICountry {
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: number;
    id: number;
    name: string;
    code: string;
}

export class CreateManyCountryDto implements ICreateManyCountryDto {
    bulk: Country[];

    constructor(data?: ICreateManyCountryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Country.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyCountryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyCountryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data;
    }

    clone(): CreateManyCountryDto {
        const json = this.toJSON();
        let result = new CreateManyCountryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyCountryDto {
    bulk: Country[];
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}